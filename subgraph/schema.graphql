type Project @entity {
  id: ID!
  # From IPFS / off chain storage
  # None of these are required, since first the event DIDOwnerChanged creates the project first
  # Then DIDAttributeChanged gets emitted, where we will see theses values filled in
  # Note - someone could not upload any data here (blank IPFS file, or never calling
  # DIDAttributeChanged). But this is okay, because that project should get challenged
  name: String
  description: String
  website: String
  twitter: String
  github: String # Make sure we call it github or something else
  avatar: String
  image: String
  categories: [Category!]
  isRepresentative: String

  createdAt: Int!
  updatedAt: Int!

  # From smart contracts directly
  owner: User
  currentChallenge: Challenge
  pastChallenges: [Challenge!]
  # If now > memberShipStartTime , this project is a member.
  # reputation = now - membershipStartTime.
  membershipStartTime: Int!
  delegates: [Bytes!] # Null if no delegate is set. There can be many delegates
  # delegateValidities: [Int!] # Time delegate is valid
  ipfsHash: String # aka DIDAttribute
  # Derived from smart contract events
  totalVotes: Int!

  # All votes a Project has made
  votes: [Vote!] @derivedFrom(field: "voter")
}

type Category @entity {
  id: ID! # id is equal to the slug, which is the name but used in the URL for consistency
  description: String!
  name: String! # the name, case insensitive
  projects: [Project!] @derivedFrom(field: "categories") # TODO - ensure this works on the categories array
  subcategories: [Category!] @derivedFrom(field: "parentCategory")
  parentCategory: Category

  createdAt: Int!
}

type Challenge @entity {
  id: ID!
  ipfsHash: String!
  description: String
  endTime: Int!
  votesFor: Int!
  votesAgainst: Int!
  project: Project!
  owner: Bytes!
  votes: [Vote!] @derivedFrom(field: "challenge")
  # This is when the challenge is resolved, which is different from end time. When we are past
  # the end time, we can implicitly calculate votesFor and votesAgainst, and determine if it
  # passed or failed. Resolved means it is called in the smart contract, and the challenge
  # is deleted from storage
  resolved: Boolean!

  createdAt: Int!
}

# For global variables
type Everest @entity {
  id: ID!
  "Owner of the Everest contract"
  owner: Bytes!
  "Approved token for fees (DAI)"
  approvedToken: Bytes!
  "Voting period for challenges"
  votingPeriodDuration: Int!
  "Challege deposit in DAI"
  challengeDeposit: BigInt!
  "Fee to apply to be in Everest"
  applicationFee: BigInt!
  "Address of the reserve bank"
  reserveBankAddress: Bytes!
  "Balance of the reserve bank (DAI)"
  reserveBankBalance: BigInt!
  "IPFS hash pointing to the charter"
  charter: Charter!

  createdAt: Int
}

type Charter @entity {
  id: ID!
  charterDescription: String
  name: String
  description: String
  website: String
  twitter: String
  avatar: String
  image: String
  categories: String
  isRepresentative: String
  # Latest created at is the latest charter
  createdAt: Int!
}

type Vote @entity {
  id: ID! # concatenation of challenge ID and voter address
  voter: Project!
  challenge: Challenge!
  choice: Choice!
  weight: Int!

  createdAt: Int!
}

enum Choice {
  Null
  Yes
  No
}

type User @entity {
  id: ID!
  name: String
  bio: String
  projects: [Project!] @derivedFrom(field: "owner")
  challenges: [Challenge!] # challenges you started
  votes: [Project!] # participation in other people's challenges
  createdAt: Int!
}

type Total @entity {
  id: ID!
  projectCount: Int
}
